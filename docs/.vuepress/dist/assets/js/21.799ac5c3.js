(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{519:function(v,_,t){"use strict";t.r(_);var n=t(15),l=Object(n.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[v._v("#")]),v._v(" 时间复杂度")]),v._v(" "),t("ol",[t("li",[v._v("忽略常数时间的操作")]),v._v(" "),t("li",[v._v("确定算法总操作数和样本数量之间的表达式关系")]),v._v(" "),t("li",[v._v("只看表达式最高阶部分")])]),v._v(" "),t("p",[v._v("如一个选择排序算法，每次都要遍历n-1-n个数查找出当前子数组中最小值做交换，0~n-1、1~n-1、···，而交换最小值到当前下标index为常数操作每次固定时间，遍历操作为等差数列和公式 化简为aN^2*bN+c，只看最高阶为2次方，粗略估计为O(N^2)")]),v._v(" "),t("p",[v._v("常见的常数操作:")]),v._v(" "),t("ul",[t("li",[v._v("算术运算")]),v._v(" "),t("li",[v._v("位运算")]),v._v(" "),t("li",[v._v("赋值、比较、自增、自减等")]),v._v(" "),t("li",[v._v("数组寻址")])]),v._v(" "),t("p",[v._v("固定时间为常数操作，时间不固定则不是常数操作")]),v._v(" "),t("p",[t("strong",[v._v("如果某个算法流程的复杂程度会根据数据状况不同而不同，那么必须按照最差情况估计")])]),v._v(" "),t("p",[v._v("如插入排序 在最差的情况下 数组中每个数都要进行交换")]),v._v(" "),t("p",[v._v("在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为 O(N)")]),v._v(" "),t("p",[v._v("最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为O(N^2)")])])}),[],!1,null,null,null);_.default=l.exports}}]);