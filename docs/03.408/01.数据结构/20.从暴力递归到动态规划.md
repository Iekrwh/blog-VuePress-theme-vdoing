---
title: 从暴力递归到动态规划
date: 2022-05-02 18:28:16
permalink: /pages/4f7ce9/
categories:
  - 408
  - 数据结构
tags:
  - 
---
# 从暴力递归到动态规划

## 暴力递归

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件（base case）
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

### 汉诺塔问题

打印n层汉诺塔从最左边移动到最右边的全部过程

![img](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/v2-68cda0fa600b3b33571933420c48061e_r.jpg)

假设有3跟柱子，左、中、右，我们细分为如下三个步骤：

1. **将1~N-1层圆盘从左 -> 中（大问题，需要继续划分为小问题）**

2. **将第N层圆盘从左 -> 右（base case）**

3. **将1~N-1层圆盘从中 -> 右（大问题，需要继续划分为小问题）**

#### 完整流程

```java
// 将left圆盘挪到right
	public static void leftToRight(int n) {
		// 只剩一个直接打印
		if (n == 1) {
			System.out.println("move 1 from left to right");
			return;
		}
		// 不止一个 先把上层的移动
		leftToMid(n - 1); // 从右移动到中间
		System.out.println("move " + n + " from left to right");
		midToRight(n - 1); // 从中间移动到右边
	}

	//左到中
	public static void leftToMid(int n) {
		if (n == 1) {
			System.out.println("move 1 from left to mid");
			return;
		}
		leftToRight(n - 1);
		System.out.println("move " + n + " from left to mid");
		rightToMid(n - 1);

	}

	//中到右
	public static void midToRight(int n) {
		if (n == 1) {
			System.out.println("move 1 mid to right");
			return;
		}
		midToLeft(n - 1);
		System.out.println("move " + n + " from mid to right");
		leftToRight(n - 1);

	}
	
	//中到左
	public static void midToLeft(int n) {
		if (n == 1) {
			System.out.println("move 1 from mid to left");
			return;
		}
		midToRight(n - 1);
		System.out.println("move " + n + " from mid to left");
		rightToLeft(n - 1);

	}
	
	
	//右到中
	public static void rightToMid(int n) {
		if (n == 1) {
			System.out.println("move 1 from right to mid");
			return;
		}
		rightToLeft(n - 1);
		System.out.println("move " + n + " from right to mid");
		leftToMid(n - 1);

	}
	
	
	//右到左
	public static void rightToLeft(int n) {
		if (n == 1) {
			System.out.println("move 1 from right to left");
			return;
		}
		rightToMid(n - 1);
		System.out.println("move " + n + " from right to left");
		midToRight(n - 1);

	}
	
	
	public static void hanoi1(int n) {
		leftToRight(n);
	}
	
	
	
	public static void main(String[] args) {
		int n=3;
		hanoi1(n);
		System.out.println("=======================");
	}
```

#### 优化写法

通过上面完整流程我们可以发现 n的规模不断减少，并且每次的交换都是从from 到 to 而 other 传递给下一个使用。

```java
	public static void f(int n, String from, String to, String other) {
		if (n == 1) {
			// 只剩一个直接移动 从 from 到 to
			System.out.println("move 1 from " + from + " to " + to);
		} else {
			// 不止一个 先把n-1从 当前位置移动到其他位置 
			f(n - 1, from, other, to);
			// 剩下n自己一个 直接 从 from 到 to
			System.out.println("move " + n + " from " + from + " to " + to);
			// 再把other的圆盘移动到
			f(n - 1, other, to, from);
		}
	}

	public static void main(String[] args) {
		int n = 3;
		if(n > 0) {
			f(n,"left","right","mid");
		}
		System.out.println("=======================");
		
	}
```

#### 非递归使用栈实现

```java
	public static class Record {
		public boolean finish1; 
		public int base;
		public String from;
		public String to;
		public String other;

		public Record(boolean f1, int b, String f, String t, String o) {
			finish1 = false;
			base = b;
			from = f;
			to = t;
			other = o;
		}
	}

		public static void hanoi3(int N) {
		if (N < 1) {
			return;
		}
		Stack<Record> stack = new Stack<>();
		stack.add(new Record(false, N, "left", "right", "mid"));
		while (!stack.isEmpty()) {
			Record cur = stack.pop();
			if (cur.base == 1) {
				System.out.println("Move 1 from " + cur.from + " to " + cur.to);
				if (!stack.isEmpty()) {
					stack.peek().finish1 = true;
				}
			} else {
				if (!cur.finish1) {
					stack.push(cur);
					stack.push(new Record(false, cur.base - 1, cur.from, cur.other, cur.to));
				} else {
					System.out.println("Move " + cur.base + " from " + cur.from + " to " + cur.to);
					stack.push(new Record(false, cur.base - 1, cur.other, cur.to, cur.from));
				}
			}
		}
	}
```



### 字符排列

#### 字符串的全部子序列

**从左往右依次尝试的模型**

打印一个字符串的全部子序列，包括空字符串

- 需要保证字符的前后顺序
- “abc” =》a,b,c,ab,ac,bc,abc,null
- 暴力穷举

```java
	/**
	 * 将字符串转为字符数组 调用process1
	 * @param s
	 * @return
	 */
	public static List<String> subs(String s){
		char[] str = s.toCharArray();
		String path ="";
		List<String> ans = new ArrayList<>();
		process1(str,0,ans,path);
		return ans;
		
	}
	/**
	 * 
	 * @param str 字符数组
	 * @param index 当前字符下标
	 * @param ans 结果集合
	 * @param path 当前子序列
	 */
	public static void process1(char[] str, int index, List<String> ans, String path) {
		//当前 index已经超过数组数量 
		if(index ==str.length) {
			ans.add(path);
			return;
		}
		//不要当前字符 path不变 index+1
		process1(str, index+1, ans, path);
		//要当前字符 path拼接当前字符 index+1
		process1(str, index+1, ans, path+String.valueOf(str[index]));
	}
```



#### 字符串的全部子序列 不出现重复子序列

与全子序列相同 只是结果集合使用了set集合去重

```java
	public static List<String> subsNoRepeat(String s) {
		char[] str = s.toCharArray();
		String path = "";
		//使用set集合去重
		HashSet<String> set = new HashSet<>(); 
		process2(str, 0, set, path);
		List<String> ans = new ArrayList<>();
		for (String cur : set) {
			ans.add(cur);
		}
		return ans;
	}
	
	
	public static void process2(char[] str, int index, HashSet<String> set, String path) {
		if (index == str.length) {
			set.add(path);
			return;
		}
		String no = path;
		process2(str, index + 1, set, no);
		String yes = path + String.valueOf(str[index]);
		process2(str, index + 1, set, yes);
	}
```



#### 字符串的全排列

```java
	public static List<String> permutation1(String s) {
		List<String> ans = new ArrayList<>();
		if (s == null || s.length() == 0) {
			return ans;
		}
		char[] str = s.toCharArray();
		// 可变集合 存放的是字符串的每个字符 方便移除和恢复
		ArrayList<Character> rest = new ArrayList<>();
		for (char c : str) {
			rest.add(c);
		}
		String path = "";
		f(rest, path, ans);
		return ans;

	}

	/**
	 * 
	 * @param rest 还剩哪些字符没有使用
	 * @param path 当前排列字符串
	 * @param ans  结果集合
	 */
	public static void f(ArrayList<Character> rest, String path, List<String> ans) {
		if (rest.isEmpty()) {
			ans.add(path);
			return;
		}
		int n = rest.size();
		for (int i = 0; i < n; i++) {
			char cur = rest.get(i);
			// 移除当前字符
			rest.remove(i);
			// 递归并使用该字符
			f(rest, path + cur, ans);
			// 恢复现场
			rest.add(i, cur);
		}
	}
	
	
	public static List<String> permutation2(String s){
		List<String> ans = new ArrayList<>();
		if (s == null || s.length() == 0) {
			return ans;
		}
		char[] str = s.toCharArray();
		g1(str, 0, ans);
		return ans;

	}

	/**
	 * 
	 * @param str 字符数组
	 * @param index 当前到哪个下标
	 * @param ans 结果集合
	 */
	public static void g1(char[] str, int index, List<String> ans) {
		if(index == str.length) {
			ans.add(String.valueOf(str));
			return;
		}
		for (int i = index; i <str.length; i++) {
			swap(str,index,i);
			g1(str,index+1,ans);
			swap(str,index,i);
		}
		
	}
	

	public static void swap(char[] str, int index, int i) {
			char temp = str[i];
			str[i] = str[index];
			str[index] = temp;
	}
	
		public static void main(String[] args) {
		String s = "acc";
		List<String> ans1 = permutation1(s);
		for (String str : ans1) {
			System.out.println(str);
		}
		System.out.println("=======");
		List<String> ans2 = permutation2(s);
		for (String str : ans2) {
			System.out.println(str);
		}
	}


```



#### 字符串的全排列 不出现重复排列

即每个字符只能使用一次

```java
	public static List<String> permutation3(String s) {
		List<String> ans = new ArrayList<>();
		if (s == null || s.length() == 0) {
			return ans;
		}
		char[] str = s.toCharArray();
		g2(str, 0, ans);
		return ans;
	}

	
	public static void g2(char[] str, int index, List<String> ans) {
		if(index == str.length) {
			ans.add(String.valueOf(str));
			return;
		}
		//用于标记字符是否被使用过
		boolean[] vis = new boolean[26];
		for (int i = index; i < str.length; i++) {
			int cur = str[i] -'a';
			//当前字符没被使用过
			if(!vis[cur]) {
				vis[cur] = true;
				swap(str, index, i);
				g2(str, index+1, ans);
				swap(str, index, i);
			}
			
		}
	}
	

	public static void swap(char[] str, int index, int i) {
			char temp = str[i];
			str[i] = str[index];
			str[index] = temp;
	}


		public static void main(String[] args) {
		String s = "acc";
		System.out.println("=======");
		List<String> ans3 = permutation3(s);
		for (String str : ans3) {
			System.out.println(str);
		}
	}
```



### 逆序一个栈 仅使用递归

给定一个栈，请逆序这个栈，不能申请额外的数据结构，只能使用递归函数

1. 移除并缓存栈顶
2. 判断栈是否为空 即判断是否为栈底
3. 如不为空 递归自身
4. 等递归base case触发 回将当前递归方法中的缓存栈顶重新入栈 即把栈底提取出来 并把保持栈的顺序
5. 创建一个新的g递归方法 用于调用上面的提取栈底方法 然后调用自身g方法  等g递归函数base case触发 将提取栈底方法返回的值 入栈压栈底 不断重复此时完成栈的反转

```java
	public static void g(Stack<Integer> stack) {
		if(stack.isEmpty()) {
			//g函数的base case
			return; 
		}
		// 获取栈底元素
		int bottom = f(stack);
		// 递归g方法
		g(stack);
		// 等待g函数的base case触发即递归结束 则将提取的栈底元素 重新压栈
		stack.push(bottom);
		
	}
	
	public static int f(Stack<Integer> stack) {
		// 移除并缓存当前栈顶
		int result = stack.pop();
		// 判断栈是否为空
		if(stack.isEmpty()) {
			// 栈为空 当前为栈底 直接返回
			return result;
		 } else {
			 // last为缓存的栈底
			 int last = f(stack);
			 // 不是栈底的 重新入栈 防止一次返回多个栈底
			 stack.push(result);
			 return last;
		 }
		
	}
	
	public static void main(String[] args) {
		Stack<Integer> test = new Stack<Integer>();
		test.push(1);
		test.push(2);
		test.push(3);
		test.push(4);
		test.push(5);
		g(test);
		while (!test.isEmpty()) {
			System.out.println(test.pop());
		}
	}

```





## 动态规划

动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决，是暴力递归的优化版本。

1. 从暴力递归中来
2. 将每一个子问题的解记录下来，避免重复计算
3. 把暴力递归的过程，抽象成了状态表达
4. 并且存在化简状态表达，使其更加简洁的可能

接着我们明确一般的解答流程：**暴力递归解法->带记忆数组的递归解法->(非递归)动态规划解法**，只要按照这个流程去做基本都能解答出来。

## 斐波那契数列

斐波那契数列的递推式是f(n)=f(n-1)+f(n-2)。(1,1,2,3,5,8...)

### 暴力递归

暴力递归之所以低效是因为存在大量的重复计算，借鉴[LeetCode题解区一位大佬的图](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)，如图所示，f(20)=f(19)+f(18)，而f(19)=f(18)+f(17)，这里就产生了重复计算，而且这种重复计算还很多，正是因为这些大量的重复计算，所以暴力递归很低效，这个算法的时间复杂度为 O(2^n)。

![img](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/16f46a9c4a5d93f2~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

```java
	public static int f1(int n) {
		if(n==1 || n==2) {
			return 1;
		}
		 return f1(n-1)+f1(n-2);
	}
	
	
	public static void main(String[] args) {
		System.out.println(f1(8));
	}

```



### 记忆搜索

步骤一的计算过程中国充斥着大量的重复计算，解决重复计算的方法很简单，用一个数组或者其他容器装起来，递归的时候判断是否已经计算过的，如果已经计算过，就直接返回。这个是典型的用过空间换时间的做法，反应到上述递归图中就是“剪枝”了。

f(20)，可看到每个分支都存在大量重复计算，如果我们能够把这些计算过的值先保存下来，是不是就可以避免了重复计算，这就是**带有备忘录的递归解法**，这也是动态规划的第一个性质：**重叠子问题**。

![img](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/16f46af84933f5f7~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

```java
/**
	 * 
	 * @param n 求第几项
	 * @param memo 缓存表
	 * @return
	 */
	public static int helper(int n, int[] memo) {
		if(n==1 || n==2) {
			return 1;
		}
		
		//当缓存第n项不为0 则说明之前算过值 直接返回缓存表的值
		if(memo[n] != 0) {
			return memo[n];
		}
		
		//没有被算过
		memo[n] = helper(n-1, memo) + helper(n-2, memo);
		return memo[n];
	}


	public static void main(String[] args) {
		System.out.println(f2(8));
		
	}
```

### 动态规划

写出来了带记忆数组的递归解法，动态规划也就基本成型了，因为这两者区别不是很大，**前者是自顶向下的，后者是自底向上的**。自顶向下的意思是，比如求f(5)，递归的做法是先递归到f(1)，然后再往上走得到f(5)；而动态规划是直接从f(1)开始往上求的。

```java
	public static int f3(int n) {
		int[] dp = new int[n+1];
		dp[1] = dp[2] = 1;
		for (int i = 3; i < dp.length; i++) {
			dp[i] = dp[i-1] + dp[i-2];
		}
		return dp[n];
	}


	public static void main(String[] args) {
		int n = 8;
		System.out.println(f3(n));
		
	}
```

### 总结

带记忆数组的递归和动态规划相似，他两的时间复杂度也相差无几，**动态规划中很关键的转移方程就是从暴力递归中而来的**，所以当遇到没做过或者不能一下子写出转移方程的，从暴力递归做起总是一个正确的选择。

## 机器人行走

```tex
假设有排成一行的N个位置记为1~N，N一定大于或等于2
开始时机器人在其中的M位置上(M一定是1~N中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到N-1位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
给定四个参数 N、M、K、P，返回方法数
```

### 暴力递归

**暴力尝试（回溯）优化成动态规划的步骤：**

1. **写出暴力尝试版本**
2. **转换成记忆化搜索（基础动态规划版本）**
3. **根据base case和调用过程画表，转换成动态规划。**
4. **优化动态规划。如斜率优化。**

```java
/**
	 * 
	 * @param n     1~N 个位置
	 * @param start 从哪个位置开始
	 * @param aim   目标位置
	 * @param k     要走多少步
	 * @return
	 */
	public static int ways1(int n, int start, int aim, int k) {
		if (n < 2 || start < 1 || start > n || aim < 1 || aim > n || k < 1) {
			return -1;
		}
		return process1(start, k, aim, n);
	}

	/**
	 * 
	 * @param cur  当前机器人在什么位置
	 * @param rest 还剩下多少步要走
	 * @param aim  目标位置
	 * @param n    有 1~n的位置
	 * @return
	 */
	public static int process1(int cur, int rest, int aim, int n) {
		// 当前步数已走完
		if (rest == 0) {
			// 当前位置是否为目标 是则返回方法数+1 否则返回0
			return cur == aim ? 1 : 0;
		}

		// 当前在1位置 只能往右(前)走
		if (cur == 1) {
			return process1(2, rest - 1, aim, n);
		}

		// 当前在n位置 只能往左(后)走
		if (cur == n) {
			return process1(cur - 1, rest - 1, aim, n);
		}

		// 左右都可以走
		return process1(cur - 1, rest - 1, aim, n) + process1(cur + 1, rest - 1, aim, n);

	}

	public static void main(String[] args) {
		System.out.println(ways1(5, 2, 4, 6));
	}
```



### 记忆缓存法

自顶向下动态规划又称记忆化搜索 上述方法求解时 多次反复求剩余k-x步数时 n-x位置的值 我们可以通过一张二维表来存储 剩余k部时 n位置的值

n和aim是**固定参数**，每次调用都不会变，而cur和k每次**调用过程都会变**，**因此ways1函数的调用结果取决于start和k的值，我们只要用一个二维表来记录每个调用过程的返回值便能大大提高效率，这种方法叫做记忆缓存法**。

```java
public static int ways2(int n, int start, int aim, int k) {
		if (n < 2 || start < 1 || start > n || aim < 1 || aim > n || k < 1) {
			return -1;
		}
		// dp为缓存表 dp[cur][rest] == -1 说明 process1(cur,rest)之前没有算过
		// dp[cur][rest] != -1 说明 process1(cur,rest)之前算过
		int[][] dp = new int[n + 1][k + 1];
		// 初始化为-1
		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= k; j++) {
				dp[i][j] = -1;
			}
		}

		return process2(start, k, aim, n, dp);
	}

	/**
	 * 
	 * @param cur  当前位置
	 * @param rest 剩余步数
	 * @param aim  目标
	 * @param n    1~n位置
	 * @param dp   缓存表
	 * @return
	 */
	public static int process2(int cur, int rest, int aim, int n, int[][] dp) {
		if (dp[cur][rest] != -1) {
			// 之前有求过 直接返回
			return dp[cur][rest];
		}

		// 之前没有算过的
		int ans = 0;
		if (rest == 0) {
			ans = cur == aim ? 1 : 0;
		} else if (cur == 1) {
			ans = process2(2, rest - 1, aim, n, dp);
		} else if (cur == n) {
			ans = process2(n - 1, rest - 1, aim, n, dp);
		} else {
			ans = process2(cur - 1, rest - 1, aim, n, dp) + process2(cur + 1, rest - 1, aim, n, dp);
		}
		// 将当前算的值记录到缓存表中
		dp[cur][rest] = ans;
		return ans;

	}

	public static void main(String[] args) {
		System.out.println(ways2(5, 2, 4, 6));
	}
```



### 动态规划

通过具体情况画表分析发现规律

![image-20220513153616696](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513153616696.png)



```
测试用例：n = 5, cur = 4, aim = 6, k = 6。
```

由于n = 5，cur的变化范围为1~5，k = 6，k的变化范围为0~6，我们可以画出一个6×7的二维表。

看base case：由于cur的变化范围为1~5不能为0，所以cur=0这一行打上×。k = 0时，cur==aim的时候才为1，其他时候为0。

当cur==1时，每一行依赖左下这一行；当cur=5时，每一行依赖左上一行；当普遍位置时，每一格依赖左上和左下两格相加。

![image-20220513162141387](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513162141387.png)

```java
public static int ways3(int n, int start, int aim, int k) {
		if (n < 2 || start < 1 || start > n || aim < 1 || aim > n || k < 1) {
			return -1;
		}
		int[][] dp = new int[n + 1][k + 1];
		// 目标位置 剩余0步 肯定为1次方法
		dp[aim][0] = 1;
		for (int rest = 1; rest <= k; rest++) {
			// 向右走的情况 当前位置 在1位置 剩余步数 = 在2位置 剩余步数-1的值
			dp[1][rest] = dp[2][rest - 1];
			for (int cur = 2; cur < n; cur++) {
				// 左右都可以走的情况 当前位置剩余步数的值 依赖于dp[cur-1][rest-1] 和 dp[cur+1][rest-1]
				dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
			}
			// 向左走的情况 当前位置 在n位置 剩余步数 = 在n-1位置 剩余步数-1的值
			dp[n][rest] = dp[n - 1][rest - 1];
		}
		// 直接返回开始位置 多少步的值
		return dp[start][k];

	}

	public static void main(String[] args) {
		System.out.println(ways3(5, 2, 4, 6));
	}
```





## 抽纸牌

```tex
给定一个整型数组arr，代表数值不同的纸牌排成一条线
玩家A和玩家B依次拿走每张纸牌
规定玩家A先拿，玩家B后拿
但是每个玩家每次只能拿走最左或最右的纸牌
玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数 即得分最高分数
```

```tex
题目：给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。
【举例】
arr=[1,2,100,4]。
开始时，玩家A只能拿走1或4。如果开始时玩家A拿走1，则排列变为[2,100,4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A...
如果开始时玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A...
玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，让排列变为[2,100,4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。
arr=[1,100,2]。
开始时，玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100。所以返回100。
```

**博弈论：双方玩家都不会在对方单独改变策略的情况下让对方获得最大收益**

### 暴力递归

```java
	public static int win1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		// 先手获得的总卡牌数值
		int first = f1(arr, 0, arr.length - 1);
		// 后手获得的总卡牌数值
		int second = g1(arr, 0, arr.length - 1);
		// 返回最大数值 为赢家
		return Math.max(first, second);
	}

	/**
	 * 先手从arr[l~r]中获得最好分数返回
	 * 
	 * @param arr 卡牌数值
	 * @param l 左边卡牌开始位置
	 * @param r 右边卡牌开始位置
	 * @return
	 */
	public static int f1(int[] arr, int l, int r) {
		// 只剩一张牌 先手取走
		if (l == r) {
			return arr[l];
		}
		// 如果先手拿的是左边的牌，那么后手只能在[L+1,R]上拿牌
		int p1 = arr[l] + g1(arr, l + 1, r);
		// 如果先手拿的是右边的牌，那么后手只能在[L,R-1]上拿牌
		int p2 = arr[r] + g1(arr, l, r - 1);
		// 这两种情况下，先手肯定会只选择对自己最有利的方式，也就是返回最大值
		return Math.max(p1, p2);

	}
	
	//后手从arr[l-r] 获得最好的分数返回
	public static int g1(int[] arr, int l, int r) {
		// 如果只剩下一张牌了，又是后手，那就没牌拿
		if (l == r) {
			return 0;
		}
		// 先手拿走了l位置的数
		int p1 = f1(arr, l + 1, r);
		// 先手拿走了r位置的数
		int p2 = f1(arr, l, r - 1);
		// 因为是后手，所以没得选，只能选得分最少的方式
		// 得分多的方式被先手给选了
		return Math.min(p1, p2);
	}

	public static void main(String[] args) {
		int[] arr = { 5, 7, 4, 5, 8, 1, 6, 0, 3, 4, 6, 1, 7 };
		System.out.println(win1(arr));
	}

```



### 简单缓存

```tex
输入为f1(arr,0,7)
```

![image-20220513165055099](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513165055099.png)

发现f(1,6)重复算了 并且可变参数为l和r 可以使用缓存

```java
	public static int win2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int n = arr.length;
		// 先手缓存表
		int[][] fmap = new int[n][n];
		// 后手缓存表
		int[][] gmap = new int[n][n];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				// 初始化为-1
				fmap[i][j] = gmap[i][j] = -1;
			}
		}
		int first = f2(arr, 0, arr.length - 1, fmap, gmap);
		int second = g2(arr, 0, arr.length - 1, fmap, gmap);
		return Math.max(first, second);
	}

	// 先手从arr[l~r]中获得最好分数返回
	public static int f2(int[] arr, int l, int r, int[][] fmap, int[][] gmap) {
		if (fmap[l][r] != -1) {
			return fmap[l][r];
		}
		int ans = 0;
		if (l == r) {
			ans = arr[l];
		} else {
			int p1 = arr[l] + g2(arr, l + 1, r, fmap, gmap);
			int p2 = arr[r] + g2(arr, l, r - 1, fmap, gmap);
			ans = Math.max(p1, p2);
		}
		fmap[l][r] = ans;

		return ans;

	}

	// 后手从arr[l-r] 获得最好的分数返回
	public static int g2(int[] arr, int l, int r, int[][] fmap, int[][] gmap) {
		if (gmap[l][r] != -1) {
			return gmap[l][r];
		}
		int ans = 0;
		if (l != r) {
			int p1 = f2(arr, l + 1, r, fmap, gmap);
			int p2 = f2(arr, l, r - 1, fmap, gmap);
			ans = Math.min(p1, p2);
		}
		gmap[l][r] = ans;

		return ans;
	}

	public static void main(String[] args) {
		int[] arr = { 5, 7, 4, 5, 8, 1, 6, 0, 3, 4, 6, 1, 7 };
		System.out.println(win2(arr));
	}

```





### 动态规划

```tex
输入样例arr=[7,4,16,15,1]
```

通过分析f函数的base case方向 f表中的对角线为arr[l]

```java
// 只剩一张牌 先手取走
if (l == r) {
    return arr[l];
}
```

得出以下f表  l 不可能＜ r 所以左下角无值

![image-20220513171955072](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513171955072.png)

再分析g函数的base case 发现g表的对角全为0

```java
// 如果只剩下一张牌了，又是后手，那就没牌拿
if (l == r) {
    return 0;
}
```

![image-20220513172123812](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513172123812.png)

再分析其他格子的情况 通过f函数 我们发现f表剩下的格子是依赖于g表的 `g[l+1][r]`和`g[l][r-1]`值 无法直接得出值 我们去分析g表

```java
// 如果先手拿的是左边的牌，那么后手只能在[L+1,R]上拿牌
int p1 = arr[l] + g1(arr, l + 1, r);
// 如果先手拿的是右边的牌，那么后手只能在[L,R-1]上拿牌
int p2 = arr[r] + g1(arr, l, r - 1);
```

通过分析g函数 发现g表是依赖于 f表中的 `f[l+1][r]`和`f[l][r-1]`的最小值

```java
// 先手拿走了l位置的数
int p1 = f1(arr, l + 1, r);
// 先手拿走了r位置的数
int p2 = f1(arr, l, r - 1);
// 因为是后手，所以没得选，只能选得分最少的方式
// 得分多的方式被先手给选了
return Math.min(p1, p2);
```

得出g表  `g[0][1]`通过`f[0][1]`的左上和左下两的最小值得出 即蓝色标注的两数的最小值得出g表中红色位置的数

**红色为得出的值 蓝色为f表依赖项 绿色为g表依赖**

![image-20220513174834750](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513174834750.png)

![image-20220513193020947](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513193020947.png)

```tex
7和4 最小为 4
4和16 最小值 4
16和15 最小值 15
15和1 最小值 1
```

而f表又是依赖于g表的 通过g表反推f表的值   

```java
// 如果先手拿的是左边的牌，那么后手只能在[L+1,R]上拿牌
int p1 = arr[l] + g1(arr, l + 1, r);
// 如果先手拿的是右边的牌，那么后手只能在[L,R-1]上拿牌
int p2 = arr[r] + g1(arr, l, r - 1);
return Math.max(p1, p2);
```

案例如下:

```java
int p1 = arr[0]+g[0+1][1];  //p1 = 7 + 0 
int p2 = arr[1]+g[0][1-1];  //p2 = 4 + 0
return Math.max(p1, p2);
//得出f[0][1] = 7
```

![image-20220513193554826](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513193554826.png)

![image-20220513193645627](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513193645627.png)

```tex
7+0=7
4+0=4
max = 7

4+0=4
16+0=16
max=16

16+0=16
15+0=15
max=16

15+0=15
1+0=1
max=15
```

我们得出了f表新相对应可以求出镜像的g表

![image-20220513193828212](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513193828212.png)

![image-20220513193903606](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513193903606.png)

再反过来推导f表

![image-20220513194626510](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513194626510.png)

![image-20220513194805666](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513194805666.png)

```tex
arr[0][2] = max( (7+4) , (16+4) ) =20
arr[1][3] = max( (4+15) , (15+4) ) =19
arr[2][4] = max( (16+1) , (1+15) ) =17
```

反推g表

![image-20220513194939669](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513194939669.png)

![image-20220513195015818](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513195015818.png)

反推f表

![image-20220513195039365](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513195039365.png)

![image-20220513195152739](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513195152739.png)

反推g表

![image-20220513195206609](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513195206609.png)

![image-20220513195222247](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513195222247.png)

反推f表

![image-20220513195236410](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513195236410.png)

![image-20220513195258554](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513195258554.png)

![image-20220513195331776](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513195331776.png)

然后取`f[0][n-1]`和`g[0][n-1]`中最大值为答案

```java
	public static int win3(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int n = arr.length;
		int[][] f = new int[n][n];
		int[][] g = new int[n][n];
		for (int i = 0; i < n; i++) {
			// f表对角线
			f[i][i] = arr[i];
		}
		// startCol为列 0为对角线已经设置过了
		for (int startCol = 1; startCol < n; startCol++) {
			int row = 0; // 从第一行开始
			int col = startCol; // 从第几列开始 跳过对角线位置的
			while (col < n) {
				f[row][col] = Math.max(arr[row] + g[row + 1][col], arr[col] + g[row][col -1 ]);
				g[row][col] = Math.min(f[row + 1][col], f[row][col - 1]);
				row++;
				col++;

			}

		}
		return Math.max(f[0][n - 1], g[0][n - 1]);
	}

	public static void main(String[] args) {
		int[] arr = { 7, 4, 16, 15, 1 };
		System.out.println(win3(arr));
	}
```

 

## 01背包

```tex
背包问题
给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值
给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量
返回能装下的最大价值
```

### 暴力递归

```java
	public static int maxValue(int[] w, int[] v, int bag) {
		if (w == null || v == null || w.length != v.length || w.length == 0) {
			return 0;
		}
		return process(w, v, 0, bag);
	}

	/**
	 * 
	 * @param w     重量数组
	 * @param v     价值数组
	 * @param index 当前在哪个商品位置
	 * @param rest  当前背包剩余容量
	 * @return
	 */
	public static int process(int[] w, int[] v, int index, int rest) {
		// 背包容量为负数
		if (rest < 0) {
			// 返回-1用于标记为不规范
			return -1;
		}
		// 当前没有物品可以挑 数组越界
		if (index == w.length) {
			return 0;
		}
		// 没有要当前物品
		int p1 = process(w, v, index + 1, rest);
		int p2 = 0;
		// 要了当前物品
		int next = process(w, v, index + 1, rest - w[index]);
		// 返回符合规范 即不为-1
		if (next != -1) {
			p2 = v[index] + next;
		}
		return Math.max(p1, p2);
	}

	public static void main(String[] args) {
		int[] weights = { 3, 2, 4, 7, 3, 1, 7 };
		int[] values = { 5, 6, 3, 19, 12, 4, 2 };
		int bag = 15;
		System.out.println(maxValue(weights, values, bag));
	}
```



### 动态规划

通过base case 发现index时 为 0

```java
// 当前没有物品可以挑 数组越界
if (index == w.length) {
    return 0;
}
```

![image-20220513215001538](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220513215001538.png)

而每一行依赖是它的下一行出结果

1. 没有要当前物品 直接继承下一行的值
2. 要了当前物品 判断背包剩余容量是否规范 如规范则当前物品价格+下一行的值
3. 要了和没有要 做最大值

```java
public static int dp(int[] w, int[] v, int bag) {
		if (w == null || v == null || w.length != v.length || w.length == 0) {
			return 0;
		}
		int n = w.length;
		int[][] dp = new int[n + 1][bag + 1];
		for (int index = n - 1; index >= 0; index--) {
			for (int rest = 0; rest <= bag; rest++) {
				int p1 = dp[index + 1][rest];
				int p2 = 0;
				int next = rest - w[index] < 0 ? -1 : dp[index + 1][rest - w[index]];
				if (next != -1) {
					p2 = v[index] + next;
				}
				dp[index][rest] = Math.max(p1, p2);
			}
		}
		return dp[0][bag];
	}

	public static void main(String[] args) {
		int[] weights = { 3, 2, 4, 7, 3, 1, 7 };
		int[] values = { 5, 6, 3, 19, 12, 4, 2 };
		int bag = 15;
		System.out.println(dp(weights, values, bag));
	}

```



### AcWing

这里是将第0行作为base case

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int V = sc.nextInt();
        int[][] dp=new int[1010][1010];
        int[] v=new int[1010];
        int[] w=new int[1010];
        for (int i = 1; i <=n ; i++) {
            v[i]=sc.nextInt();
            w[i]=sc.nextInt();
        }
        for (int i = 1; i <=n ; i++) {
            for (int j = 0; j <= V; j++) {
                dp[i][j]=dp[i-1][j];  //复制为上一个物品的价格
                //当前j为背包容量从0开始到V实际背包容量结束
                if (j >= v[i]){  //关键代码  如当前背包容量大于或者等于当前物品v[i]的体积  则执行以下代码
                    dp[i][j]=Math.max(dp[i][j],dp[i-1][j-v[i]]+w[i]);  //比较价格  比较复制上一个价格  和
                }
            }
        }
        System.out.println(dp[n][V]);


    }
}
```

### 结合版

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int V = sc.nextInt();
        int[][] dp=new int[1010][1010];
        int[] v=new int[1010];
        int[] w=new int[1010];
        for (int i = 0; i <n ; i++) {
            v[i]=sc.nextInt();
            w[i]=sc.nextInt();
        }
        for (int i = n-1; i >=0 ; i--) {
            for (int j = 0; j <= V; j++) {
                dp[i][j]=dp[i+1][j];  //复制为上一个物品的价格
                //当前j为背包容量从0开始到V实际背包容量结束
                if (j >= v[i]){  //关键代码  如当前背包容量大于或者等于当前物品v[i]的体积  则执行以下代码
                    dp[i][j]=Math.max(dp[i][j],dp[i+1][j-v[i]]+w[i]);  //比较价格  比较复制上一个价格  和
                }
            }
        }
        System.out.println(dp[0][V]);


    }
}
```

## 字符转化

```tex
规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果
```

### 暴力递归

```java
public static int number(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		return process(str.toCharArray(), 0);
	}

	/**
	 * 
	 * @param str 字符数组
	 * @param i   当前字符下标
	 * @return
	 */
	public static int process(char[] str, int i) {
		// 如果当前i已经到达字符串尾 说明前面的字符都是可以转换 直接返回+1次
		if (i == str.length) {
			return 1;
		}
		// 当前字符为单独的0 说明前面字符没有带上这0 或者 加上0之后超过27
		if (str[i] == '0') {
			// 说明本次转换不符合规范 直接返回0次
			return 0;
		}
		// 当前字符单个转换
		int ways = process(str, i + 1);
		// 如果i+1不越界 并且与后面数字结合不超过27 即可以与后一个字符两个进行转换
		if (i + 1 < str.length && (str[i] - '0') * 10 + (str[i + 1] - '0') < 27) {
			ways += process(str, i + 2);
		}
		return ways;
	}
```

### 动态规划

```java
	// 从右到左的动态规划
	public static int dp1(String s) {
		if (s == null || s.length() == 0) {
			return 0;
		}
		char[] str = s.toCharArray();
		int n = str.length;
		int[] dp = new int[n + 1];
		dp[n] = 1;
		for (int i = n - 1; i >= 0; i--) {
			if (str[i] != '0') {
				int ways = dp[i + 1];
				if (i + 1 < str.length && (str[i] - '0') * 10 + (str[i + 1] - '0') < 27) {
					ways += dp[i + 2];
				}
				dp[i] = ways;
			}

		}
		return dp[0];
	}
	
```

```java
	// 从左到右的动态规划
	public static int dp2(String s) {
		if (s == null || s.length() == 0) {
			return 0;
		}
		char[] str = s.toCharArray();
		if (str[0] == '0') {
			return 0;
		}
		int n = str.length;
		int[] dp = new int[n];
		dp[0] = 1;
		for (int i = 1; i < n; i++) {
			// 当前字符为0
			if (str[i] == '0') {
				/**
				 * str[i-1] == '0' 当前字符的前一个字符为0 00无法转换 str[i-2] > '2' 当前字符的前一个字符大于2 30超过27无法转换
				 * i-2 >= 0防止越界 dp[i-2]==0 如果当前字符合并前字符 并且 dp[i-2]==0 说明之前的字符都没有转换次数 直接返回0
				 */
				if (str[i - 1] == '0' || str[i - 1] > '2' || (i - 2 >= 0 && dp[i - 2] == 0)) {
					return 0;
				} else {

					dp[i] = i - 2 >= 0 ? dp[i - 2] : 1;
				}
			} else {
				//继承上个结果
				dp[i] = dp[i - 1];
				if (str[i - 1] != '0' && (str[i - 1] - '0') * 10 + str[i] - '0' < 27) {
					//
					dp[i] += i - 2 >= 0 ? dp[i - 2] : 1;
				}
			}
		}
		return dp[n - 1];

	}
```

## [691. 贴纸拼词](https://leetcode.cn/problems/stickers-to-spell-word/)

```tex
给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文
arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来
返回需要至少多少张贴纸可以完成这个任务
例子：str= "babac"，arr = {"ba","c","abcd"}
ba + ba + c  3  abcd + abcd 2  abcd+ba 2
所以返回2
```

### 暴力递归

暴力递归不要尝试提交 会超时

**朴素法**

```java
public static int minStickers1(String[] stickers, String target) {
		int ans = process1(stickers, target);
		return ans == Integer.MAX_VALUE ? -1 : ans;
	}

	/**
	 * 
	 * @param stickers 剪纸数组
	 * @param target   目标字符
	 * @return
	 */
	public static int process1(String[] stickers, String target) {
		if (target.length() == 0) {
			return 0;
		}
		int min = Integer.MAX_VALUE;
		for (String first : stickers) {
			String rest = minus(target, first);
			// 经minus处理后 字符串变少了 说明当前first有使用到当前剪纸
			if (rest.length() != target.length()) {
				// 递归尝试是否能将rest全部剪完
				min = Math.min(min, process1(stickers, rest));
			}
		}
		// 如果min == Integer.MAX_VALUE说明没有命中if分支 即当前递归不能再剪了 不能+1否则int溢出所以+0
		// 如果min != Integer.MAX_VALUE说明命中了if分支 说明有剪到某些字符 加上first+1
		return min + (min == Integer.MAX_VALUE ? 0 : 1);
	}

	public static String minus(String s1, String s2) {
		char[] str1 = s1.toCharArray();// 目标字符数组
		char[] str2 = s2.toCharArray();// 剪纸字符数组
		int[] count = new int[26];
		for (char c : str1) {
			count[c - 'a']++;
		}
		for (char d : str2) {
			count[d - 'a']--;
		}
		StringBuffer sb = new StringBuffer();
		// 根据相减后的字符数组 做字符拼接 返回rest剩余字符串
		for (int i = 0; i < count.length; i++) {
			if (count[i] > 0) {
				for (int j = 0; j < count[i]; j++) {
					sb.append((char) (i + 'a'));
				}
			}
		}
		return sb.toString();
	}
```

**优化剪纸写法**

```java
public static int minStickers2(String[] stickers, String target) {
		int n = stickers.length;
		// 创建一张二维表 用于存放每个剪纸的字符数组统计
		int[][] counts = new int[n][26];
		for (int i = 0; i < counts.length; i++) {
			char[] str = stickers[i].toCharArray();
			for (char c : str) {
				counts[i][c - 'a']++;
			}
		}
		int ans = process2(counts, target);
		return ans == Integer.MAX_VALUE ? -1 : ans;

	}

	/**
	 * 
	 * @param counts 剪纸的字符统计
	 * @param target 目标字符串
	 * @return
	 */
	public static int process2(int[][] counts, String target) {
		if (target.length() == 0) {
			return 0;
		}
		// 对目标字符串做词频
		char[] charArray = target.toCharArray();
		int[] tcounts = new int[26];
		for (char c : charArray) {
			tcounts[c - 'a']++;
		}

		int n = counts.length;
		int min = Integer.MAX_VALUE;
		for (int i = 0; i < n; i++) {
			// 尝试哪个剪纸
			int[] sticker = counts[i];
			// 剪枝策略 因为所有字符都做了字符统计
			// 如果target第一个字符 在剪纸中没出现过 说明当前尝试可以舍弃(总有可能会尝试到 但不是在此次递归中尝试)
			if (sticker[charArray[0] - 'a'] > 0) {
				StringBuffer sb = new StringBuffer();
				for (int j = 0; j < 26; j++) {
					// 当前字符在剪纸大于0
					if (tcounts[j] > 0) {
						// 作减法
						int nums = tcounts[j] - sticker[j];
						for (int k = 0; k < nums; k++) {
							// 剩下的字符 拼接为rest
							sb.append((char) (j + 'a'));
						}
					}
				}
				String rest = sb.toString();
				min = Math.min(min, process2(counts, rest));
			}
		}
		return min + (min == Integer.MAX_VALUE ? 0 : 1);
	}
```



### 记忆化搜索

```java
public static int minStickers3(String[] stickers, String target) {
		int n = stickers.length;
		int[][] counts = new int[n][26];
		for (int i = 0; i < counts.length; i++) {
			char[] str = stickers[i].toCharArray();
			for (char c : str) {
				counts[i][c - 'a']++;
			}
		}

		HashMap<String, Integer> dp = new HashMap<>();
		// base case
		dp.put("", 0);
		// 带着缓存表递归
		int ans = process3(counts, target, dp);
		return ans == Integer.MAX_VALUE ? -1 : ans;

	}

	public static int process3(int[][] counts, String target, HashMap<String, Integer> dp) {
		// 缓存表中有直接返回
		if (dp.containsKey(target)) {
			return dp.get(target);
		}
		// 对目标字符串做词频
		char[] charArray = target.toCharArray();
		int[] tcounts = new int[26];
		for (char c : charArray) {
			tcounts[c - 'a']++;
		}

		int n = counts.length;
		int min = Integer.MAX_VALUE;
		for (int i = 0; i < n; i++) {
			// 尝试哪个剪纸
			int[] sticker = counts[i];
			// 剪枝策略 因为所有字符都做了字符统计
			// 如果target第一个字符 在剪纸中没出现过 说明当前尝试可以舍弃(总有可能会尝试到 但不是在此次递归中尝试)
			if (sticker[charArray[0] - 'a'] > 0) {
				StringBuffer sb = new StringBuffer();
				for (int j = 0; j < 26; j++) {
					// 当前字符在剪纸大于0
					if (tcounts[j] > 0) {
						// 作减法
						int nums = tcounts[j] - sticker[j];
						for (int k = 0; k < nums; k++) {
							// 剩下的字符 拼接为rest
							sb.append((char) (j + 'a'));
						}
					}
				}
				String rest = sb.toString();
				min = Math.min(min, process3(counts, rest));
			}
		}
		int ans = min + (min == Integer.MAX_VALUE ? 0 : 1);
		// 算完放入缓存
		dp.put(target, ans);
		return ans;

	}
```

## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)



### 暴力递归

```java
public int longestCommonSubsequence1(String s1, String s2) {
		if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
			return 0;
		}
		char[] str1 = s1.toCharArray();
		char[] str2 = s2.toCharArray();
		return process1(str1, str2, str1.length - 1, str2.length - 1);
	}

	/**
	 * 可能性分类: 1. 一定不以str1[i]字符结尾 也一定不以str2[j]字符结尾 
	 * 2. 可能以str1[i]字符结尾 但一定不以str2[j]字符结尾
	 * 3. 一定不以str1[i]字符结尾 但可能以str2[j]子符结尾 
	 * 4. 必须以str1[i]字符结尾 也必须以str2[j]字符结尾
	 * 
	 * @param str1 字符串1
	 * @param str2 字符串2
	 * @param i    str1[0...i]和str2[0...j]，这个范围上最长公共子序列长度是多少?
	 * @param j
	 * @return 最长公共子序列长度
	 */
	public int process1(char[] str1, char[] str2, int i, int j) {
		if (i == 0 && j == 0) {
			// str1和str2只剩下一个字符 下标为0的字符 两字符相同返回+1长度 否则返回0
			return str1[i] == str2[j] ? 1 : 0;
		} else if (i == 0) {
			// str1只剩一个字符 但str2不只一个字符
			if (str1[i] == str2[j]) {
				return 1;
			} else {
				// 不相同 str2继续减少
				return process1(str1, str2, i, j - 1);
			}
		} else if (j == 0) {
			// str2只剩一个字符 但str1不只一个字符
			if (str1[i] == str2[j]) {
				return 1;
			} else {
				// str2不变 str1继续减少
				return process1(str1, str2, i - 1, j);
			}
		} else {
			// str1和str2都不单只一个字符
			// str1减少情况
			int p1 = process1(str1, str2, i - 1, j);
			// str2减少情况
			int p2 = process1(str1, str2, i, j - 1);
			// 首先判断当前str1[i]和str2[j]是否相同 如果相同则代表当前字符也是长度1的子序列并同时减少str1和str2
			int p3 = str1[i] == str2[j] ? (1 + process1(str1, str2, i - 1, j - 1)) : 0;
			return Math.max(p1, Math.max(p2, p3));
		}

	}
```

### 动态规划

![ds_151](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/1637723434-VqVjcD-20211118154529.png)

![ds_152](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/1637723434-SuAjUh-20211118154530.png)

```java
public int longestCommonSubsequence(String s1, String s2) {
		if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
			return 0;
		}
		char[] str1 = s1.toCharArray();
		char[] str2 = s2.toCharArray();
		int n = str1.length;
		int m = str2.length;
		int[][] dp = new int[n][m];
		// base case1
		dp[0][0] = str1[0] == str2[0] ? 1 : 0;
		// base case2
		for (int j = 1; j < m; j++) {
			dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j - 1];
		}
		// base case3
		for (int i = 1; i < n; i++) {
			dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];
		}
		// other
		for (int i = 1; i < n; i++) {
			for (int j = 1; j < m; j++) {
				int p1 = dp[i - 1][j];
				int p2 = dp[i][j - 1];
				int p3 = str1[i] == str2[j] ? (1 + dp[i - 1][j - 1]) : 0;
				dp[i][j] = Math.max(p1, Math.max(p2, p3));
			}
		}
		return dp[n - 1][m - 1];
	}
```

## [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)
解法1. 可以在最长公共子序列解法中 将原始字符串反转求两字符串最长公共子序列即是答案

### 暴力递归

```java
	public static int lpsl1(String s) {
		if (s == null || s.length() == 0) {
			return 0;
		}

		char[] str = s.toCharArray();
		return process1(str, 0, str.length - 1);
	}

	public static int process1(char[] str, int l, int r) {
		// 只剩一个字符 肯定是回文
		if (l == r) {
			return 1;
		}
		// 只剩两个字符 分情况
		if (l == r - 1) {
			return str[l] == str[r] ? 2 : 1;
		}
		// 字符串头和尾同时收缩 即不以l开头 也不以r结尾
		int p1 = process1(str, l + 1, r - 1);
		// 字符串头收缩 不以l开头 以r结尾
		int p2 = process1(str, l + 1, r);
		// 字符串尾收缩 以l开头 不以r结尾
		int p3 = process1(str, l, r - 1);
		// 如果当前字符串的头和尾 相等则需要将此时2个字符统计上去 否则不作处理 即以l开头 也以r结尾
		int p4 = str[l] == str[r] ? 2 + process1(str, l + 1, r - 1) : 0;

		return Math.max(Math.max(p1, p2), Math.max(p3, p4));
	}
```



### 动态规划
![](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/20220515154435.png)
```java
		//先填上右下角的 方便对角线和对角线+1填值
		dp[n-1][n-1] = 1;
		for (int i = 0; i < n-1; i++) {
			//base case1
			dp[i][i] = 1;
			//base case2
			dp[i][i+1] = str[i] ==str[i+1] ? 2:1;
		}
```
填完对角线和对角线+1位置后 分析依赖发现求一个未知值它依赖是它的左边、左下角和下边的值
![](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/20220515155032.png)
```java
	public static int lpsl2(String s) {
		if (s == null || s.length() == 0) {
			return 0;
		}
		char[] str = s.toCharArray();
		int n = str.length;
		int[][] dp = new int[n][n];
		// 先填上右下角的 方便对角线和对角线+1填值
		dp[n - 1][n - 1] = 1;
		for (int i = 0; i < n - 1; i++) {
			// base case1
			dp[i][i] = 1;
			// base case2
			dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
		}

		for (int l = n - 3; l >= 0; l--) {
			for (int r = l + 2; r < n; r++) {
				// 字符串头和尾同时收缩 即不以l开头 也不以r结尾
				int p1 = dp[l + 1][r - 1];
				// 字符串头收缩 不以l开头 以r结尾
				int p2 = dp[l + 1][r];
				// 字符串尾收缩 以l开头 不以r结尾
				int p3 = dp[l][r - 1];
				// 如果当前字符串的头和尾 相等则需要将此时2个字符统计上去 否则不作处理 即以l开头 也以r结尾
				int p4 = str[l] == str[r] ? 2 + dp[l + 1][r - 1] : 0;
				dp[l][r] = Math.max(Math.max(p1, p2), Math.max(p3, p4));
			}
		}

		return dp[0][n - 1];
	}
```
### 优化
通过上面dp解法我们发现 一个未知位置的值它依赖的是它的 左下、左、下、2+左中最大值
![](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/20220515160018.png)
而它的左和下，也依赖过左下又是求的是最大值，所以左和下不可能比左下小，我们可以把左下的依赖去掉，只有当str[l]和str[r]相等时才求出2+左下

```java
	public static int lpsl3(String s) {
		if (s == null || s.length() == 0) {
			return 0;
		}
		char[] str = s.toCharArray();
		int n = str.length;
		int[][] dp = new int[n][n];
		// 先填上右下角的 方便对角线和对角线+1填值
		dp[n - 1][n - 1] = 1;
		for (int i = 0; i < n - 1; i++) {
			// base case1
			dp[i][i] = 1;
			// base case2
			dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
		}

		for (int l = n - 3; l >= 0; l--) {
			for (int r = l + 2; r < n; r++) {
				// 字符串头收缩 不以l开头 以r结尾
				int p2 = dp[l + 1][r];
				// 字符串尾收缩 以l开头 不以r结尾
				int p3 = dp[l][r - 1];
				dp[l][r] = Math.max(p2, p3);
				if (str[l] == str[r]) {
					dp[l][r] = Math.max(dp[l][r], 2 + dp[l + 1][r - 1]);
				}
			}
		}

		return dp[0][n - 1];
	}

```
## 马的遍历
```tex
请同学们自行搜索或者想象一个象棋的棋盘，
然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
给你三个 参数 x，y，k
返回“马”从(0,0)位置出发，必须走k步
最后落在(x,y)上的方法数有多少种? 
```

马走日 8种跳的方法

![image-20220515170015446](https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220515170015446.png)

### 暴力递归

```java
/**
 * 
 * @param a 目标x坐标
 * @param b 目标y坐标
 * @param k 要走多少不
 * @return
 */
public static int jump(int a, int b, int k) {
	return process(0, 0, k, a, b);
}

public static int process(int x, int y, int rest, int a, int b) {
	// 越界base case
	if (x < 0 || x > 9 || y < 0 || y > 8) {
		return 0;
	}
	if (rest == 0) {
		// 当前步数为0 并且当前位置在目标位置 次数+1
		return (x == a && y == b) ? 1 : 0;
	}

	int ways = process(x + 2, y + 1, rest - 1, a, b);
	ways += process(x + 1, y + 2, rest - 1, a, b);
	ways += process(x - 1, y + 2, rest - 1, a, b);
	ways += process(x - 2, y + 1, rest - 1, a, b);
	ways += process(x - 2, y - 1, rest - 1, a, b);
	ways += process(x - 1, y - 2, rest - 1, a, b);
	ways += process(x + 1, y - 2, rest - 1, a, b);
	ways += process(x + 2, y - 1, rest - 1, a, b);
	return ways;
}
```

### 动态规划

```java
	public static int dp(int a, int b, int k) {
		int[][][] dp = new int[10][9][k + 1];
		// 当前剩余步数为0 并且在目标位置 为0 base case2
		dp[a][b][0] = 1;
		for (int rest = 1; rest <= k; rest++) {
			for (int x = 0; x < 10; x++) {
				for (int y = 0; y < 9; y++) {
					int ways = pick(dp, x + 2, y + 1, rest - 1);
					ways += pick(dp, x + 1, y + 2, rest - 1);
					ways += pick(dp, x - 1, y + 2, rest - 1);
					ways += pick(dp, x - 2, y + 1, rest - 1);
					ways += pick(dp, x - 2, y - 1, rest - 1);
					ways += pick(dp, x - 1, y - 2, rest - 1);
					ways += pick(dp, x + 1, y - 2, rest - 1);
					ways += pick(dp, x + 2, y - 1, rest - 1);
					dp[x][y][rest] = ways;

				}
			}
		}
		return dp[0][0][k];
	}

	// 防止越界方法
	public static int pick(int[][][] dp, int x, int y, int rest) {
		if (x < 0 || x > 9 || y < 0 || y > 8) {
			return 0;
		}
		return dp[x][y][rest];
	}
```

## 泡咖啡

```tex
给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间
给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
假设所有人拿到咖啡之后立刻喝干净，
返回从开始等到所有咖啡机变干净的最短时间
三个参数：int[] arr、int N，int a、int b
```



