---
title: random的随机行为
date: 2022-03-18 16:03:55
permalink: /pages/64e136/
categories:
  - 408
  - 数据结构
tags:
  - 
---
# random的随机行为

Math.random中的随机数 为伪随机数 产生一个 [0,1) 浮点型数

并且每个数产生的概率 为**等概率** 生成的数字是均匀的，也就是说该区间内部的每个数字生成的几率是相同的

```java
int sum = 0;
for (int i = 0; i <= 100000; i++) {
    double ans =  Math.random();
    if(ans < 0.3) {
        sum++;
    }
}
//产生 100000 次 [0,1)的随机数 如果小于0.3则计数
//查询小于0.3出现的概率  为30%左右  所以我们可以判断MJath.random的随机行为为等概率的 
System.out.println((double)sum /100000.0 );
```

## 给定一个1~5等概率随机的函数 返回一个7~15等概率的新函数

首先1~5是等概率的 我们需要将此函数改为为只返回 0 和 1 的等概率函数

即如果给定的随机函数返回结果为3则重新生成随机数 直到生成不为3的结果  这样我们就可以获得一个 0 ~ 1 等概率随机生成的函数

7 ~ 15 为9个数 则对应的二进制为 1 0 1 需要3个二进制位 我们需要调用3次改造后的 0~1等概率发生器

第一次结果左位移2位 第二次结果左位移1位 第三次结果不位移, 最后将3次结果相加,这样我们获得0~13的等概率函数, 并且我们进行截取 超过9的数重新调用 0~13等概率函数

```java
do{
    int ans =  f4();//0~13等概率函数
}while(ans > 9);
return ans;
```

这样我们获得一个0~9的等概率发生器 最后调用0~9等概率发生器 + 7则完成此新函数

## 给定一个0~1不等概率的随机函数 返回0~1等概率随机函数

首先0~1是不等概率 我们通过调用两次此函数

0 0 概率则为 p*p

1 1 概率则为 (1-p)*(1-p)

0 1 概率为 p*(1-p)

1 0 概率为 (1-p)*p

通过筛选 01 和 10 结果即可以返回一个等概率的函数

01则返回0

10则返回1

```java
// 给定一个 0和1不等概率的函数
public static int x() {
	return Math.random() < 0.8 ? 0 : 1;
}

// 返回一个等概率0和1的新函数
public static int x2() {
	int ans = 0;
	do {
		ans = x();
	} while (ans == x()); //如果两次都结果为0或1则重新调用x函数
    //只有 ans = 0 x()返回1
    //和 ans = 1 x()返回0 才返回ans
	return ans;
}
```

