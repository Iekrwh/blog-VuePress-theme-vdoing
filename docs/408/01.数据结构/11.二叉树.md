---
title: 二叉树
date: 2022-03-18 16:03:55
permalink: /pages/3e25e1/
categories:
  - 408
  - 数据结构
tags:
  - 
---
# 二叉树

## 递归序

先序遍历 : 头节点 左节点 右节点

中序遍历 : 左节点 头节点 右节点

后序遍历 : 左节点 右节点 头节点

```java
	public static class Node {
		public int val;
		public Node left;
		public Node right;
		
		
		public Node(int val) {
			this.val = val;
		}

	}
	
	public static void f(Node head) {
		if(head == null) {
			return;
		}
		System.out.println("先序遍历"+head.val); //头节点 左节点 右节点
		f(head.left);
//		System.out.println("中序遍历"+head.val); //左节点 头节点 右节点
		f(head.right);
//		System.out.println("后序遍历"+head.val); //左节点 右节点 头节点
	}
	
	public static void main(String[] args) {
		Node head = new Node(1);
		head.left = new Node(2);
		head.right = new Node(3);
		head.left.left = new Node(4);
		head.left.right = new Node(5);
		head.right.left = new Node(6);
		head.right.right = new Node(8);
		
		f(head);
		
	}
```

## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```java
	public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	class Solution {
		public boolean isSameTree(TreeNode p, TreeNode q) {
			if (p == null ^ q == null) { //有一个为空 另外一个不为空 返回
				return false;
			}
			if (p == null && q == null) { //两者都为空
				return true;
			}
			//两者值相等 && 左树相等 && 右树相等
			return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
		}
	}
```

## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```java
	public class TreeNode {
	    int val;
	    TreeNode left;
	    TreeNode right;
	    TreeNode() {}
	    TreeNode(int val) { this.val = val; }
	    TreeNode(int val, TreeNode left, TreeNode right) {
	        this.val = val;
	        this.left = left;
	        this.right = right;
	    }
	}
	
	class Solution {
	    public boolean isSymmetric(TreeNode root) {
	    	return isSameTree(root,root);//自己与自己比较
	    }
	    
	    public boolean isSameTree(TreeNode p, TreeNode q) {
			if (p == null ^ q == null) { //有一个为空 另外一个不为空 返回
				return false;
			}
			if (p == null && q == null) { //两者都为空
				return true;
			}
			//两者值相等 && 左树与`右树相等 && 右树与`左树相等
			return p.val == q.val && isSameTree(p.left, q.right) && isSameTree(p.right, q.left);
		}
	}
```

## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```java
	public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	class Solution {
		public int maxDepth(TreeNode root) {
			if (root == null) {
				return 0;
			}
			return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
		}
	}
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
	public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	class Solution {

		public TreeNode buildTree(int[] preorder, int[] inorder) {
			if (preorder == null || inorder == null || preorder.length != inorder.length) {
				return null;
			}
             Map<Integer, Integer> IndexMap = new HashMap<>();
			for (int i = 0; i < inorder.length; i++) {
				IndexMap.put(inorder[i], i);
			}

			return f(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1,IndexMap);
		}

		private TreeNode f(int[] preorder, int l1, int r1, int[] inorder, int l2, int r2,Map<Integer, Integer> IndexMap) {
			if (l1 > r1) { //
				return null;
			}
			TreeNode head = new TreeNode(preorder[l1]); // 头节点
			if (l1 == r1) { // 只有一个元素时
				return head;
			}
			int index = IndexMap.get(preorder[l1]); // 查找当前头节点在中序遍历数组的位置
			// 左树构建 l1+1到 l1 + index - l2 为左树的先序遍历范围 		l2到index-1为中序遍历范围
			head.left = f(preorder, l1 + 1, l1 + index - l2, inorder, l2, index - 1,IndexMap); // 注意左树和右树构建采用的遍历范围均相同长度
			// 右树构建 l1 + index - l2(即左树的结束范围) +1 到 r1为右树先序遍历范围 		index+1到r2为右树中序遍历的范围
			head.right = f(preorder, l1 + index - l2 + 1, r1, inorder, index + 1, r2,IndexMap);
			return head;
		}
	}
```

## [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```java
public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	class Solution {
		public List<List<Integer>> levelOrderBottom(TreeNode root) {
			List<List<Integer>> ans = new ArrayList<>();
			if (root == null) { // 根节点为空直接返回空列表
				return ans;
			}
			LinkedList<TreeNode> queue = new LinkedList<>();
			queue.add(root); // 将头节点加入队列中
			while (!queue.isEmpty()) {
				int size = queue.size(); // 获取队列当前长度
				List<Integer> tans = new LinkedList<>();
				for (int i = 0; i < size; i++) {
					TreeNode temp = queue.poll();
					tans.add(temp.val); // 获取头节点的值 放入局部队列中
					if (temp.left != null) {
						queue.add(temp.left); // 左节点非空 加入到队列中
					}
					if (temp.right != null) {
						queue.add(temp.right); // 右节点非空 加入队列中
					}

				}
				ans.add(0, tans); // 将上次队列缓存头节点清空后的节点值加入到结果集合中
			}
			return ans;

		}
	}
```

## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

平衡二叉树:一个二叉树*每个节点* 的**左右两个子树的高度差的绝对值不超过 1** 。

```java
	public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	class Solution {
		public boolean isBalanced(TreeNode root) {
			return process(root).isBalanced; //直接返回root节点的信息
		}

		public class info {
			public boolean isBalanced; // 是否为平衡二叉树
			public int height; // 高度

			public info(boolean isBalanced, int height) {
				this.isBalanced = isBalanced;
				this.height = height;
			}

		}

		public info process(TreeNode root) {
			if (root == null) { // 空节点
				return new info(true, 0);
			}
			info leftInfo = process(root.left); // 左树信息
			info rightInfo = process(root.right); // 右树信息

			int height = Math.max(leftInfo.height, rightInfo.height) + 1; // 当前节点高度为 左和右树最大值 +1
			boolean isBalanced = leftInfo.isBalanced && rightInfo.isBalanced
					&& Math.abs(leftInfo.height - rightInfo.height) <= 1; //左树和右树为平衡二叉树 并且 左右树高度差不大于1
			return new info(isBalanced, height);
		}

	}
```

## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

搜索二叉树:**左树的值比根节点的值小，右树的值比根节点的值大**

一颗搜索二叉树**中序遍历是递增顺序**

```java
	public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	class Solution {
		public boolean isValidBST(TreeNode root) {
			return isBST(root).isBst;
		}
		
		public class info{
			boolean isBst;
			int max;
			int min;
			public info(boolean isBst, int max, int min) {
				this.isBst = isBst;
				this.max = max;
				this.min = min;
			}
			
		}
		
		public info isBST(TreeNode root) {
			if(root == null) { //头节点为空则返回空
				return null;
			}
			info leftinfo = isBST(root.left); //递归进入左树
			info rightinfo = isBST(root.right); //递归进入右树
			
			int max = root.val; //假设最大值为自身
			int min = root.val;//假设最小值为自身
			if(leftinfo != null) { //左树非空
				max = Math.max(max, leftinfo.max); //提取左树信息
				min = Math.min(min, leftinfo.min);
			}
			if(rightinfo != null) {
				max = Math.max(max, rightinfo.max); //提取右树信息
				min = Math.min(min, rightinfo.min);
			}
			
			boolean bst = true; //先假设为搜索二叉树
			if(leftinfo !=null && !leftinfo.isBst) { //如果左树不满足则 头节点标记为不是二叉树
				bst =false;
			}
			if(rightinfo !=null && !rightinfo.isBst) { //如果右树不满足则 头节点标记为不是二叉树
				bst =false;
			}
			
			
			boolean lefiBst = leftinfo == null ? true : (leftinfo.max < root.val); //如果左树信息为空返回ture  否则左树最大值必须小于当前节点值
			boolean rightBst = rightinfo == null ? true : (rightinfo.min > root.val);//如果右树信息为空返回ture  否则右树最小值必须大于当前节点值
			if(!lefiBst || !rightBst) { //不满足搜索二叉树规则
				bst = false;
			}
			
			return new info(bst, max, min);
		}
		
	}
```

## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```java
public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	class Solution {

		public boolean isSum = false;

		public boolean hasPathSum(TreeNode root, int targetSum) {
			if(root ==null) { //根节点为空 直接返回false
				return false;
			}
			tree(root, 0, targetSum);
			return isSum;

		}

		public void tree(TreeNode root, int preSum, int sum) {
			if (root.left == null && root.right == null) { //当前头节点左右子节点都为空
				if (preSum + root.val == sum) { //当前头节点值与上次sum 为target则找到
					isSum = true;
				}
				return;
			}

			preSum += root.val; //累加当前sum
			if (root.left != null) { //左节点有叶节点 递归进去
				tree(root.left, preSum, sum);
			}
			if (root.right != null) { //右节点有叶节点 递归进去
				tree(root.right, preSum, sum);
			}
		}
	}
```

## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```java
	public class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;

		TreeNode() {
		}

		TreeNode(int val) {
			this.val = val;
		}

		TreeNode(int val, TreeNode left, TreeNode right) {
			this.val = val;
			this.left = left;
			this.right = right;
		}
	}

	class Solution {
		public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
			List<List<Integer>> ans = new ArrayList<>();
			if (root == null) {
				return ans;
			}
			ArrayList<Integer> path = new ArrayList<>();
			process(root, path, 0, targetSum, ans);
			return ans;
		}

		public void process(TreeNode root, ArrayList<Integer> path, int preSum, int sum, List<List<Integer>> ans) {
			if (root.left == null & root.right == null) {
				if (root.val + preSum == sum) {
					path.add(root.val); // 添加当前节点路径
//					List<Integer> newPath = copy(path); // 拷贝
					List<Integer> newPath = (List<Integer>) path.clone(); // 本质上是浅拷贝 但里面存储的是值 所以复制了里面值 如里面存储的是引用不应用深拷贝
					
					ans.add(newPath); // 添加到结果集合中
					path.remove(path.size() - 1); // 删除当前路径
				}
			}
			preSum += root.val; // 累加 无需回溯 因为是值传递 不是引用传递
			path.add(root.val); // 记录节点
			if (root.left != null) { // 递归
				process(root.left, path, preSum, sum, ans);
			}
			if (root.right != null) { // 递归
				process(root.right, path, preSum, sum, ans);
			}
			path.remove(path.size() - 1); // 恢复现场
		}
		
	}
```

