---
title: 堆(优先级队列)
date: 2022-03-18 16:03:56
permalink: /pages/88e08c/
categories:
  - 408
  - 数据结构
tags:
  - 
---
# 堆(优先级队列)

**堆**(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做**一棵完全二叉树的<u>数组</u>对象**。

完全二叉树：**叶子结点只能出现在最下层和次下层**，且最下层的叶子结点集中在树的**左部**。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。

**每一棵子树**的**根结点最大**的堆(即根节点大于等于子节点)叫做最大堆或**大根堆**，**根结点最小**的堆叫做最小堆或**小根堆**

## 优先级队列(PriorityQueue)与比较器

```java

	public static class MyComparator implements Comparator<Integer> {

		// 负数,第一个参数在前
		// 正数,第二个参数在前
		// 0,不作交换
		@Override
		public int compare(Integer o1, Integer o2) {
			if (o1 > o2) {
				return -1;
			} else if (o2 > o1) {
				return 1;
			} else {
				return 0;
			}
		}

	}

	public static void main(String[] args) {
		PriorityQueue<Integer> heap = new PriorityQueue<>(); // 默认小根堆的优先队列
		heap.add(5);
		heap.add(3);
		heap.add(8);
		heap.add(1);
		System.out.println(heap.peek()); // 查看队头
		for (Integer integer : heap) {
			System.out.print(integer + " ");
		}
		System.out.println();

//		PriorityQueue<Integer> heap2 = new PriorityQueue<>(new MyComparator()); // 大根堆的优先队列 构造时传入比较器
		PriorityQueue<Integer> heap2 = new PriorityQueue<>((o1,o2)-> o2-o1); // 大根堆的优先队列 构造时传入比较器
		heap2.add(5);
		heap2.add(3);
		heap2.add(8);
		heap2.add(1);
		System.out.println(heap2.peek()); // 查看队头
		for (Integer integer : heap2) {
			System.out.print(integer + " ");
		}
		System.out.println();

	}
```

## 数组实现堆



## 堆排序



## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java
public class ListNode {
		int val;
		ListNode next;

		ListNode() {
		}

		ListNode(int val) {
			this.val = val;
		}

		ListNode(int val, ListNode next) {
			this.val = val;
			this.next = next;
		}
	}

	public ListNode mergeKLists(ListNode[] lists) {
		PriorityQueue<ListNode> heap = new PriorityQueue<ListNode>((o1, o2) -> o1.val - o2.val); //自定义比较器的最小堆
		for (ListNode listNode : lists) { //遍历链表数组
			if (listNode != null) { 
				heap.add(listNode); //非空则push到最小堆
			}
		}
		if (heap.isEmpty()) { //堆中没有
			return null;
		}
		ListNode head = heap.poll(); // 弹出最小堆头
		ListNode pre = head;
		if (pre.next != null) {
			heap.add(pre.next); // 如果pre下一跳 不为空 直接push到最小堆中
		}
		while (!heap.isEmpty()) { //最小堆不为空
			ListNode cur = heap.poll(); //弹出栈顶 即最小值
			pre.next = cur; //下一跳 连接
			pre = cur; //更新当前节点
			if (cur.next != null) { //当前节点 下一跳不为空则添加到最小堆中
				heap.add(cur.next);
			}
		}
		return head;

	}
```
