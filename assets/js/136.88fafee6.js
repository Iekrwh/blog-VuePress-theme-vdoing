(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{469:function(t,r,v){"use strict";v.r(r);var _=v(3),n=Object(_.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"结构型模式-structural-pattern"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式-structural-pattern"}},[t._v("#")]),t._v(" 结构型模式(Structural Pattern)")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("结构型模式")]),t._v("关注点“怎样组合对象/类？”所以我们关注下类的组合关系")]),t._v(" "),r("li",[r("strong",[t._v("类结构型模式")]),t._v("关心类的组合，由多个类可以组合成一个更大的（"),r("strong",[t._v("继承")]),t._v("）")]),t._v(" "),r("li",[r("strong",[t._v("对象结构型模式")]),t._v("关心类与对象的组合，通过"),r("strong",[t._v("关联关系")]),t._v("在一个类中定义另一个类的实例对象（"),r("strong",[t._v("组合")]),t._v("）")]),t._v(" "),r("li",[t._v("根据“"),r("strong",[t._v("合成复用原则")]),t._v("”，在系统中尽量"),r("strong",[t._v("使用关联关系来替代继承关系")]),t._v("，因此大部分结构型模式都是"),r("strong",[t._v("对象结构型模式")]),t._v("。")])]),t._v(" "),r("hr"),t._v(" "),r("ul",[r("li",[r("strong",[t._v("适配器模式")]),t._v("（Adapter Pattern）：两个不兼容接口之间适配的桥梁")]),t._v(" "),r("li",[t._v("桥接模式（Bridge Pattern）：相同功能抽象化与实现化解耦，抽象与实现可以独立升级。")]),t._v(" "),r("li",[t._v("过滤器模式（Filter、Criteria Pattern）：使用不同的标准来过滤一组对象")]),t._v(" "),r("li",[r("strong",[t._v("组合模式")]),t._v("（Composite Pattern）：相似对象进行组合，形成树形结构")]),t._v(" "),r("li",[r("strong",[t._v("装饰器模式")]),t._v("（Decorator Pattern）：向一个现有的对象添加新的功能，同时又不改变其结构")]),t._v(" "),r("li",[r("strong",[t._v("外观模式")]),t._v("（Facade Pattern）：向现有的系统添加一个接口，客户端访问此接口来隐藏系统的复杂性。")]),t._v(" "),r("li",[t._v("享元模式（Flyweight Pattern）：尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象")]),t._v(" "),r("li",[r("strong",[t._v("代理模式")]),t._v("（Proxy Pattern）：一个类代表另一个类的功能")])])])}),[],!1,null,null,null);r.default=n.exports}}]);