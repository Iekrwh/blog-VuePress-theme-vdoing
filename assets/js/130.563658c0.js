(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{462:function(t,e,r){"use strict";r.r(e);var v=r(3),s=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"设计模式的概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的概念"}},[t._v("#")]),t._v(" 设计模式的概念")]),t._v(" "),e("p",[t._v("对接口编程而不是对实现编程。")]),t._v(" "),e("p",[t._v("优先使用对象组合而不是继承。")]),t._v(" "),e("h2",{attrs:{id:"设计模式的基石"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的基石"}},[t._v("#")]),t._v(" 设计模式的基石")]),t._v(" "),e("ul",[e("li",[t._v("封装 继承 多态")]),t._v(" "),e("li",[t._v("顺序 判断 循环")])]),t._v(" "),e("h2",{attrs:{id:"三种类型设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三种类型设计模式"}},[t._v("#")]),t._v(" 三种类型设计模式")]),t._v(" "),e("p",[t._v("三种类型设计模式只是围绕着组件的生命周期来设计的。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Iekrwh/images/md-images/image-20220419154449133.png",alt:"image-20220419154449133"}})]),t._v(" "),e("h3",{attrs:{id:"创建型模式-creational-patterns"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式-creational-patterns"}},[t._v("#")]),t._v(" 创建型模式（Creational Patterns）")]),t._v(" "),e("ul",[e("li",[t._v("单例（Singleton）模式")]),t._v(" "),e("li",[t._v("原型（Prototype）模式")]),t._v(" "),e("li",[t._v("工厂方法（FactoryMethod）模式")]),t._v(" "),e("li",[t._v("抽象工厂（AbstractFactory）模式")]),t._v(" "),e("li",[t._v("建造者（Builder）模式")])]),t._v(" "),e("h3",{attrs:{id:"结构型模式-structural-patterns"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式-structural-patterns"}},[t._v("#")]),t._v(" 结构型模式（Structural Patterns）")]),t._v(" "),e("ul",[e("li",[t._v("代理（Proxy）模式")]),t._v(" "),e("li",[t._v("适配器（Adapter）模式")]),t._v(" "),e("li",[t._v("桥接（Bridge）模式")]),t._v(" "),e("li",[t._v("装饰（Decorator）模式")]),t._v(" "),e("li",[t._v("外观（Facade）模式")]),t._v(" "),e("li",[t._v("享元（Flyweight）模式")]),t._v(" "),e("li",[t._v("组合（Composite）模式")]),t._v(" "),e("li",[t._v("过滤器模式（Filter Pattern）")])]),t._v(" "),e("h3",{attrs:{id:"行为型模式-behavioral-patterns"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式-behavioral-patterns"}},[t._v("#")]),t._v(" 行为型模式（Behavioral Patterns）")]),t._v(" "),e("ul",[e("li",[t._v("模板方法（Template Method）模式")]),t._v(" "),e("li",[t._v("策略（Strategy）模式")]),t._v(" "),e("li",[t._v("命令（Command）模式")]),t._v(" "),e("li",[t._v("职责链（Chain of Responsibility）模式")]),t._v(" "),e("li",[t._v("状态（State）模式")]),t._v(" "),e("li",[t._v("观察者（Observer）模式")]),t._v(" "),e("li",[t._v("中介者（Mediator）模式")]),t._v(" "),e("li",[t._v("迭代器（Iterator）模式")]),t._v(" "),e("li",[t._v("访问者（Visitor）模式")]),t._v(" "),e("li",[t._v("备忘录（Memento）模式")]),t._v(" "),e("li",[t._v("解释器（Interpreter）模式")])]),t._v(" "),e("h2",{attrs:{id:"设计的7大原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计的7大原则"}},[t._v("#")]),t._v(" 设计的7大原则")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("开闭原则")]),t._v("（Open Closed Principle，OCP）")]),t._v(" "),e("ul",[e("li",[t._v("软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification）"),e("strong",[t._v("【即扩展新类而不是对通过修改旧类来实现新的功能】")])]),t._v(" "),e("li",[t._v("合成复用原则、里氏替换原则相辅相成，都是开闭原则的具体实现规范")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("里氏替换原则")]),t._v("（Liskov Substitution Principle，LSP）")]),t._v(" "),e("ul",[e("li",[t._v("继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）"),e("strong",[t._v("【继承父类而不去改变父类】")])])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("依赖倒置原则")]),t._v("（Dependence Inversion Principle，DIP）")]),t._v(" "),e("ul",[e("li",[t._v("高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）"),e("strong",[t._v("【面向接口编程，而不是面向实现类】")])])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("单一职责原则")]),t._v("（Single Responsibility Principle，SRP）")]),t._v(" "),e("ul",[e("li",[t._v("一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）"),e("strong",[t._v("【每个类只负责自己的事情，而不是变成万能】")])])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("接口隔离原则")]),t._v("（Interface Segregation Principle，ISP）")])]),t._v(" "),e("li",[e("p",[t._v("一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。"),e("strong",[t._v("【各个类建立自己的专用接口，而不是建立万能接口】")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("迪米特法则")]),t._v("（Law of Demeter，LoD）")]),t._v(" "),e("ul",[e("li",[t._v("最少知识原则（Least Knowledge Principle，LKP)")]),t._v(" "),e("li",[t._v("只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）"),e("strong",[t._v("【无需直接交互的两个类，如果需要交互，使用中间者】")]),t._v(" "),e("strong",[t._v("过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低")])])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("合成复用原则")]),t._v("（Composite Reuse Principle，CRP）")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）")])]),t._v(" "),e("li",[e("p",[t._v("软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。"),e("strong",[t._v("【优先组合（把对方当做属性来进行组合），其次继承】")])])])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);