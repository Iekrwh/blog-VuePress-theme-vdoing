(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{359:function(s,a,v){"use strict";v.r(a);var _=v(3),t=Object(_.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[s._v("#")]),s._v(" 继承")]),s._v(" "),a("p",[s._v("继承是面向对象三大特征之一。可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法")]),s._v(" "),a("p",[s._v("格式:pubilc class 子类名 extends 父类名{}")]),s._v(" "),a("p",[s._v("如:")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Zi")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Fu")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("Fu:是父类，又称为基类，超类")]),s._v(" "),a("p",[s._v("Zi:是子类，又称为派生类")]),s._v(" "),a("h2",{attrs:{id:"继承的好处与弊端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承的好处与弊端"}},[s._v("#")]),s._v(" 继承的好处与弊端")]),s._v(" "),a("p",[a("strong",[s._v("好处")]),s._v(":")]),s._v(" "),a("p",[s._v("提高了代码的复用性(多个类相同的成员或者方法可以放到同一个类中)")]),s._v(" "),a("p",[s._v("提高了代码的维护性（如果方法的代码需要修改，修改一处即可）")]),s._v(" "),a("p",[a("strong",[s._v("弊端:")])]),s._v(" "),a("p",[s._v("继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类也不得不跟着变化，削弱了子类的独立性")]),s._v(" "),a("p",[s._v("什么时候使用继承？")]),s._v(" "),a("p",[s._v("继承体现的关系:is a")]),s._v(" "),a("p",[s._v("假设法:我有两个类A和B，如果他们满足A是B的一种，或者B是A的一种，就说明他们存在继承关系，这个时候就可以考虑使用继承，否则不能滥用继承，因为不确定父类什么时候改变，而子类是否需要这些继承的属性或方法。")]),s._v(" "),a("p",[s._v("相对于父类必须是子类的真子集")]),s._v(" "),a("h2",{attrs:{id:"继承中变量的访问特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承中变量的访问特点"}},[s._v("#")]),s._v(" 继承中变量的访问特点")]),s._v(" "),a("p",[s._v("在子类方法中访问一个变量的访问顺序是")]),s._v(" "),a("ol",[a("li",[s._v("子类局部范围找")]),s._v(" "),a("li",[s._v("子类成员范围找")]),s._v(" "),a("li",[s._v("父类成员范围找")]),s._v(" "),a("li",[s._v("如果都没有则报错（不考虑父类的父类）")])]),s._v(" "),a("h2",{attrs:{id:"super"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#super"}},[s._v("#")]),s._v(" super")]),s._v(" "),a("p",[s._v("super关键字用法与this关键字的用法相似")]),s._v(" "),a("p",[s._v("this:代表本类对象的引用")]),s._v(" "),a("p",[s._v("super:代表父类存储空间的标识（也可以理解为父类对象引用）")]),s._v(" "),a("h2",{attrs:{id:"继承中构造方法的访问特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承中构造方法的访问特点"}},[s._v("#")]),s._v(" 继承中构造方法的访问特点")]),s._v(" "),a("p",[s._v("子类中所有的构造方法默认都会访问父类中无参的构造方法")]),s._v(" "),a("p",[s._v("因为子类会继承父类中的数据，可能还会使用父类的数据。所以在子类初始化前，一定要先完成父类数据的初始化")]),s._v(" "),a("p",[s._v("每一个子类构造方法的第一条语句默认都是:super()，如果父类中并没有无参构造方法则报错")]),s._v(" "),a("p",[a("strong",[s._v("super()调用的是父类的构造方法")])]),s._v(" "),a("p",[s._v("如果父类中没有无参构造方法")]),s._v(" "),a("p",[s._v("只有带参构造方法则通过使用super关键字去调用父类中的代词构造方法")]),s._v(" "),a("p",[s._v("建议在父类中提供一个无参构造方法")]),s._v(" "),a("h2",{attrs:{id:"继承中成员方法的访问特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承中成员方法的访问特点"}},[s._v("#")]),s._v(" 继承中成员方法的访问特点")]),s._v(" "),a("p",[s._v("通过子类对象访问一个方法顺序")]),s._v(" "),a("ol",[a("li",[s._v("子类成员范围找")]),s._v(" "),a("li",[s._v("父类成员范围找")]),s._v(" "),a("li",[s._v("如果都没有则报错（不考虑父类的父类j）")])]),s._v(" "),a("h2",{attrs:{id:"方法重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法重写"}},[s._v("#")]),s._v(" 方法重写")]),s._v(" "),a("h3",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[s._v("#")]),s._v(" 概述")]),s._v(" "),a("p",[s._v("子类中出现了和父类一模一样的方法声明")]),s._v(" "),a("p",[s._v("并在子类重写方法可以在方法中使用super关键字调用父类的方法")]),s._v(" "),a("h3",{attrs:{id:"校验是否是方法重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#校验是否是方法重写"}},[s._v("#")]),s._v(" 校验是否是方法重写")]),s._v(" "),a("p",[s._v("在重写构造方法上方加上@ovrride  如果报错则此子类构造方法不是重写")]),s._v(" "),a("h3",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[s._v("#")]),s._v(" 注意事项")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("父类中的私有方法是不允许重写的")])]),s._v(" "),a("li",[a("p",[s._v("声明方法父类与子类必须相同  如不加public关键字   系统默认也是有声明关键字,但不用public权限高")]),s._v(" "),a("p",[a("strong",[s._v("(public > 默认 >  private)")])])])]),s._v(" "),a("h2",{attrs:{id:"继承注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承注意事项"}},[s._v("#")]),s._v(" 继承注意事项")]),s._v(" "),a("ol",[a("li",[s._v("一个子类不能继承多个父类 只有继承一个父类")]),s._v(" "),a("li",[s._v("可以使用嵌套子类继承父类,父类继承父类的父类(多层继承)")])])])}),[],!1,null,null,null);a.default=t.exports}}]);