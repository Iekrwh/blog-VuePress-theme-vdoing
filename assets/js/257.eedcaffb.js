(window.webpackJsonp=window.webpackJsonp||[]).push([[257],{586:function(v,_,t){"use strict";t.r(_);var s=t(3),n=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"方法参数传递是值还是引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法参数传递是值还是引用"}},[v._v("#")]),v._v(" 方法参数传递是值还是引用")]),v._v(" "),_("ol",[_("li",[v._v("如果为基本数据类型（8种）则为值传递")]),v._v(" "),_("li",[v._v("引用类型可分为类引用类型（类）、接口引用类型（接口）和数组引用类型（数组）(其实引用传递是特殊值传递,传递为内存的地址)")]),v._v(" "),_("li",[v._v("包装类比较特殊 java会自动拆箱 虽然实参传递是引用地址 但形参已经是拆箱后的内容 两者不相同无法作修改")])]),v._v(" "),_("p",[v._v("结论:")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Java"),_("strong",[v._v("基本数据类型")]),v._v("传递参数时是"),_("strong",[v._v("值传递")]),v._v("；")]),v._v(" "),_("p",[_("strong",[v._v("引用类型")]),v._v("传递参数时是"),_("strong",[v._v("引用传递")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("值传递时，将"),_("strong",[v._v("实参的值")]),v._v("传递一份给形参；")]),v._v(" "),_("p",[v._v("引用传递时，将"),_("strong",[v._v("实参的地址值")]),v._v("传递一份给形参。")])]),v._v(" "),_("li",[_("p",[v._v("值传递时，实参把它的值传递给对应的形参，"),_("strong",[v._v("函数接收的是原始值的一个拷贝")]),v._v("，此时内存中"),_("strong",[v._v("存在两个相等的基本类型")]),v._v("，"),_("strong",[v._v("即实参和形参")]),v._v("，后面方法中的操作都是对"),_("strong",[v._v("形参这个值的修改，不影响实参的值")]),v._v("。")]),v._v(" "),_("p",[v._v("引用传递时，实参的引用(地址，而不是参数的值)被传递给方法中相对应的形参，函数接收的是原始值的内存地址；在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。")])])])])}),[],!1,null,null,null);_.default=n.exports}}]);