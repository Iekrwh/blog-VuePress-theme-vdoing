(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{361:function(t,v,_){"use strict";_.r(v);var a=_(3),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"多态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[t._v("#")]),t._v(" 多态")]),t._v(" "),v("p",[t._v("同一个对象,在不同时刻表现出来的不同形态")]),t._v(" "),v("h2",{attrs:{id:"多态的前提"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多态的前提"}},[t._v("#")]),t._v(" 多态的前提")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("有继承/实现关系")])]),t._v(" "),v("li",[v("p",[t._v("有方法重写")])]),t._v(" "),v("li",[v("p",[t._v("有父类引用指向子类对象")])])]),t._v(" "),v("h2",{attrs:{id:"多态中成员访问特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多态中成员访问特点"}},[t._v("#")]),t._v(" 多态中成员访问特点")]),t._v(" "),v("p",[t._v("成员变量:编译看左边,执行看左边")]),t._v(" "),v("p",[t._v("成员变量必须是引用类中有的才能编译  并且输出是引用类的值")]),t._v(" "),v("p",[t._v("成员方法:编译看左边,执行看右边")]),t._v(" "),v("p",[t._v("成员方法必须是引用类中有的才能编译  并且如对象中重写了此方法 则输出对象中的方法 否则输出引用中的方法")]),t._v(" "),v("p",[t._v("成员方法有重写,成员变量没有")]),t._v(" "),v("h2",{attrs:{id:"多态好处和弊端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多态好处和弊端"}},[t._v("#")]),t._v(" 多态好处和弊端")]),t._v(" "),v("p",[t._v("好处是 定义个方法使用父类作为参数,使用时只需将子类传进就可以使用")]),t._v(" "),v("p",[t._v("弊端是 无法使用子类特有而父类中没有的方法")]),t._v(" "),v("h2",{attrs:{id:"多态中的转型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多态中的转型"}},[t._v("#")]),t._v(" 多态中的转型")]),t._v(" "),v("p",[t._v("向上转型")]),t._v(" "),v("p",[t._v("从子到父   父类引用指向子类对象")]),t._v(" "),v("p",[t._v("向下转型")]),t._v(" "),v("p",[t._v("从父到子  父类引用转为子类对象")])])}),[],!1,null,null,null);v.default=s.exports}}]);